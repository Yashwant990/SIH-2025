# tasks.py

from celery_app import celery
# Import DB_PATH (though not strictly needed here, it's used below)
from utils import extract_skills, ml_recommend_career, DB_PATH
import sqlite3
import pickle
import os

# ----------------- Celery Worker ML Model Loading -----------------
# Load the ML model once when the Celery worker starts up.
# This ensures the model is available in the Celery process memory.

CELERY_CLF, CELERY_MLB = None, None
MODEL_PATH = "model.pkl" 

try:
    if os.path.exists(MODEL_PATH):
        with open(MODEL_PATH, "rb") as f:
            CELERY_CLF, CELERY_MLB = pickle.load(f)
        print("✅ Celery worker: ML model loaded successfully")
    else:
        # This will be printed if model.pkl is missing
        print("❌ Celery worker: model.pkl not found at", MODEL_PATH)

except Exception as e:
    # Catch any file reading or unpickling errors
    print(f"❌ Celery worker: Error loading model: {e}")


@celery.task(bind=True, name="tasks.parse_resume_task")
def parse_resume_task(self, text, user_id, aspiration):
    try:
        # Detect if skill list or resume (Logic from original tasks.py)
        lines = [line.strip().lower() for line in text.splitlines() if line.strip()]
        if len(lines) > 3 and all(len(line.split()) <= 3 for line in lines):
            skills = lines[:20]
        else:
            # Calls the extract_skills function from utils.py
            skills = extract_skills(text)

        # Call the updated ml_recommend_career, passing the model objects
        # The ml_recommend_career function (in utils.py) is now designed to accept clf and mlb.
        careers = ml_recommend_career(skills, CELERY_CLF, CELERY_MLB, top_n=3)

        # Log to DB (using the DB_PATH from utils.py)
        # Note: In a production setup, database interaction should ideally
        # be done with a connection pool, but this follows the current structure.
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute(
            "INSERT INTO user_progress (user_id, topic, step) VALUES (?, ?, ?)",
            (user_id, "resume_analysis", f"Found {len(skills)} skills"),
        )
        conn.commit()
        conn.close()

        # The result includes careers generated by the ML model or the fallback
        return {"skills": skills, "careers": careers, "aspiration": aspiration}
        
    except Exception as e:
        print(f"Task tasks.parse_resume_task failed: {e}")
        return {"error": str(e)}